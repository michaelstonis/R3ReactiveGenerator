using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ReactiveGenerator;

[Generator]
public class WhenAnyValueGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Get all classes that have reactive properties
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (s, _) => IsCandidateClass(s),
                transform: (ctx, _) => GetSemanticTargetForClass(ctx))
            .Where(c => c is not null);

        // Register the attribute source
        context.RegisterPostInitializationOutput(ctx =>
        {
            // Add the base observer type
            ctx.AddSource(
                "PropertyObserver.g.cs", 
                SourceText.From(PropertyObserverSource, Encoding.UTF8));
        });

        // Combine compilation and classes
        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        // Generate source
        context.RegisterSourceOutput(
            compilationAndClasses,
            (spc, source) => Execute(source.Left, source.Right.Cast<INamedTypeSymbol>().ToList(), spc));
    }

    private static bool IsCandidateClass(SyntaxNode node)
    {
        // Look for classes that might have reactive properties
        if (node is not ClassDeclarationSyntax classDeclaration)
            return false;

        // Must be partial
        if (!classDeclaration.Modifiers.Any(m => m.ValueText == "partial"))
            return false;

        // Must have property with [Reactive] attribute
        return classDeclaration.Members
            .OfType<PropertyDeclarationSyntax>()
            .Any(p => p.AttributeLists.Count > 0 &&
                     p.AttributeLists.Any(al => 
                         al.Attributes.Any(a => 
                             a.Name.ToString() is "Reactive" or "ReactiveAttribute")));
    }

    private static INamedTypeSymbol? GetSemanticTargetForClass(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration);
        return symbol;
    }

    private static void Execute(
        Compilation compilation,
        List<INamedTypeSymbol> classes,
        SourceProductionContext context)
    {
        if (classes.Count == 0) return;

        // Generate a separate file for each class
        foreach (var classSymbol in classes)
        {
            var source = GenerateExtensionsForClass(classSymbol);
            var fileName = $"{classSymbol.Name}.WhenAnyValue.g.cs";
            context.AddSource(fileName, SourceText.From(source, Encoding.UTF8));
        }
    }

    private static string GenerateExtensionsForClass(INamedTypeSymbol classSymbol)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.ComponentModel;");
        sb.AppendLine("using ReactiveGenerator.Internal;");
        sb.AppendLine();

        // Add namespace
        var containingNamespace = classSymbol.ContainingNamespace;
        if (!containingNamespace.IsGlobalNamespace)
        {
            sb.AppendLine($"namespace {containingNamespace}");
        }
        else
        {
            sb.AppendLine("namespace Global");
        }
        sb.AppendLine("{");

        // Generate class-specific extension class
        sb.AppendLine($"    public static class {classSymbol.Name}WhenAnyValueExtensions");
        sb.AppendLine("    {");

        var reactiveProperties = classSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.GetAttributes()
                .Any(a => a.AttributeClass?.Name is "ReactiveAttribute" or "Reactive"));

        foreach (var property in reactiveProperties)
        {
            GenerateWhenAnyValueMethod(sb, classSymbol, property);
            sb.AppendLine();
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GenerateWhenAnyValueMethod(
        StringBuilder sb, 
        INamedTypeSymbol classSymbol,
        IPropertySymbol property)
    {
        var className = classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var propertyType = property.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        
        sb.AppendLine($"        public static IObservable<{propertyType}> WhenAny{property.Name}(");
        sb.AppendLine($"            this {className} source)");
        sb.AppendLine("        {");
        sb.AppendLine($"            return new PropertyObserver<{className}, {propertyType}>(");
        sb.AppendLine("                source,");
        sb.AppendLine($"                nameof({className}.{property.Name}),");
        sb.AppendLine($"                () => source.{property.Name});");
        sb.AppendLine("        }");
    }

    private const string PropertyObserverSource = @"
using System;
using System.ComponentModel;

namespace ReactiveGenerator.Internal
{
    internal class PropertyObserver<TSource, TProperty> : IObservable<TProperty>
        where TSource : INotifyPropertyChanged
    {
        private readonly TSource _source;
        private readonly string _propertyName;
        private readonly Func<TProperty> _getter;

        public PropertyObserver(TSource source, string propertyName, Func<TProperty> getter)
        {
            _source = source;
            _propertyName = propertyName;
            _getter = getter;
        }

        public IDisposable Subscribe(IObserver<TProperty> observer)
        {
            // Send initial value
            observer.OnNext(_getter());

            // Subscribe to property changes
            void Handler(object? s, PropertyChangedEventArgs e)
            {
                if (e.PropertyName == _propertyName)
                {
                    observer.OnNext(_getter());
                }
            }

            _source.PropertyChanged += Handler;

            // Return disposable to cleanup subscription
            return new SubscriptionDisposable(() => _source.PropertyChanged -= Handler);
        }

        private class SubscriptionDisposable : IDisposable
        {
            private readonly Action _cleanup;
            private bool _isDisposed;

            public SubscriptionDisposable(Action cleanup)
            {
                _cleanup = cleanup;
            }

            public void Dispose()
            {
                if (!_isDisposed)
                {
                    _cleanup();
                    _isDisposed = true;
                }
            }
        }
    }
}";
}
