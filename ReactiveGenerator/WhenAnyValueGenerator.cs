using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ReactiveGenerator;

[Generator]
public class WhenAnyValueGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Get all classes that have reactive properties
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (s, _) => IsCandidateClass(s),
                transform: (ctx, _) => GetSemanticTargetForClass(ctx))
            .Where(c => c is not null);

        // Register the attribute source
        context.RegisterPostInitializationOutput(ctx =>
        {
            // Add the base observer types
            ctx.AddSource(
                "PropertyObserver.g.cs", 
                SourceText.From(PropertyObserverSource, Encoding.UTF8));
            
            ctx.AddSource(
                "WeakEventManager.g.cs",
                SourceText.From(WeakEventManagerSource, Encoding.UTF8));
        });

        // Combine compilation and classes
        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        // Generate source
        context.RegisterSourceOutput(
            compilationAndClasses,
            (spc, source) => Execute(source.Left, source.Right.Cast<INamedTypeSymbol>().ToList(), spc));
    }

    private static bool IsCandidateClass(SyntaxNode node)
    {
        // Look for classes that might have reactive properties
        if (node is not ClassDeclarationSyntax classDeclaration)
            return false;

        // Must be partial
        if (!classDeclaration.Modifiers.Any(m => m.ValueText == "partial"))
            return false;

        // Must have property with [Reactive] attribute
        return classDeclaration.Members
            .OfType<PropertyDeclarationSyntax>()
            .Any(p => p.AttributeLists.Count > 0 &&
                     p.AttributeLists.Any(al => 
                         al.Attributes.Any(a => 
                             a.Name.ToString() is "Reactive" or "ReactiveAttribute")));
    }

    private static INamedTypeSymbol? GetSemanticTargetForClass(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration);
        return symbol;
    }

    private static void Execute(
        Compilation compilation,
        List<INamedTypeSymbol> classes,
        SourceProductionContext context)
    {
        if (classes.Count == 0) return;

        // Generate a separate file for each class
        foreach (var classSymbol in classes)
        {
            var source = GenerateExtensionsForClass(classSymbol);
            var fileName = $"{classSymbol.Name}.WhenAnyValue.g.cs";
            context.AddSource(fileName, SourceText.From(source, Encoding.UTF8));
        }
    }

    private static string GenerateExtensionsForClass(INamedTypeSymbol classSymbol)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.ComponentModel;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using ReactiveGenerator.Internal;");
        sb.AppendLine();

        // Add namespace
        var containingNamespace = classSymbol.ContainingNamespace;
        if (!containingNamespace.IsGlobalNamespace)
        {
            sb.AppendLine($"namespace {containingNamespace}");
        }
        else
        {
            sb.AppendLine("namespace Global");
        }
        sb.AppendLine("{");

        // Generate class-specific extension class
        sb.AppendLine($"    public static class {classSymbol.Name}WhenAnyValueExtensions");
        sb.AppendLine("    {");

        var reactiveProperties = classSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.GetAttributes()
                .Any(a => a.AttributeClass?.Name is "ReactiveAttribute" or "Reactive"));

        foreach (var property in reactiveProperties)
        {
            GenerateWhenAnyValueMethod(sb, classSymbol, property);
            sb.AppendLine();
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GenerateWhenAnyValueMethod(
        StringBuilder sb, 
        INamedTypeSymbol classSymbol,
        IPropertySymbol property)
    {
        var className = classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var propertyType = property.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        
        sb.AppendLine($"        public static IObservable<{propertyType}> WhenAny{property.Name}(");
        sb.AppendLine($"            this {className} source)");
        sb.AppendLine("        {");
        sb.AppendLine($"            return new PropertyObserver<{className}, {propertyType}>(");
        sb.AppendLine("                source,");
        sb.AppendLine($"                nameof({className}.{property.Name}),");
        sb.AppendLine($"                () => source.{property.Name});");
        sb.AppendLine("        }");
    }

    private const string PropertyObserverSource = @"
using System;
using System.Collections.Concurrent;
using System.ComponentModel;
using System.Threading;

namespace ReactiveGenerator.Internal
{
    internal sealed class PropertyObserver<TSource, TProperty> : IObservable<TProperty>, IDisposable
        where TSource : INotifyPropertyChanged
    {
        private readonly object _gate = new object();
        private readonly TSource _source;
        private readonly string _propertyName;
        private readonly Func<TProperty> _getter;
        private readonly WeakEventManager<PropertyChangedEventHandler> _eventManager;
        private readonly PropertyChangedEventHandler _handler;
        private bool _isDisposed;
        private readonly ConcurrentDictionary<IDisposable, byte> _subscriptions;

        public PropertyObserver(TSource source, string propertyName, Func<TProperty> getter)
        {
            _source = source ?? throw new ArgumentNullException(nameof(source));
            _propertyName = propertyName ?? throw new ArgumentNullException(nameof(propertyName));
            _getter = getter ?? throw new ArgumentNullException(nameof(getter));
            _eventManager = new WeakEventManager<PropertyChangedEventHandler>();
            _subscriptions = new ConcurrentDictionary<IDisposable, byte>();
            _handler = HandlePropertyChanged;
        }

        public IDisposable Subscribe(IObserver<TProperty> observer)
        {
            if (observer == null) throw new ArgumentNullException(nameof(observer));

            lock (_gate)
            {
                if (_isDisposed)
                {
                    observer.OnCompleted();
                    return Disposable.Empty;
                }

                var subscription = new Subscription(this, observer);
                _subscriptions.TryAdd(subscription, 0);

                try
                {
                    // Send initial value
                    observer.OnNext(_getter());

                    // Subscribe to property changes
                    _eventManager.AddEventHandler(_source, ""PropertyChanged"", _handler);
                }
                catch (Exception ex)
                {
                    observer.OnError(ex);
                    subscription.Dispose();
                    return Disposable.Empty;
                }

                return subscription;
            }
        }

        public void Dispose()
        {
            lock (_gate)
            {
                if (!_isDisposed)
                {
                    foreach (var subscription in _subscriptions.Keys)
                    {
                        subscription.Dispose();
                    }
                    _subscriptions.Clear();
                    _eventManager.RemoveEventHandler(_source, ""PropertyChanged"", _handler);
                    _isDisposed = true;
                }
            }
        }

        private void HandlePropertyChanged(object? sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName != _propertyName && !string.IsNullOrEmpty(e.PropertyName)) 
                return;

            foreach (var subscription in _subscriptions.Keys)
            {
                if (subscription is Subscription activeSubscription)
                {
                    try
                    {
                        var observer = activeSubscription.Observer;
                        if (observer != null)
                        {
                            var value = _getter();
                            observer.OnNext(value);
                        }
                        else
                        {
                            // Observer was collected, remove the subscription
                            activeSubscription.Dispose();
                        }
                    }
                    catch (Exception ex)
                    {
                        if (activeSubscription.Observer is { } observer)
                        {
                            observer.OnError(ex);
                        }
                        activeSubscription.Dispose();
                    }
                }
            }
        }

        private sealed class Subscription : IDisposable
        {
            private readonly PropertyObserver<TSource, TProperty> _parent;
            private readonly WeakReference<IObserver<TProperty>> _weakObserver;
            private int _disposed;

            public Subscription(PropertyObserver<TSource, TProperty> parent, IObserver<TProperty> observer)
            {
                _parent = parent;
                _weakObserver = new WeakReference<IObserver<TProperty>>(observer);
            }

            public IObserver<TProperty>? Observer
            {
                get
                {
                    _weakObserver.TryGetTarget(out var observer);
                    return observer;
                }
            }

            public void Dispose()
            {
                if (Interlocked.Exchange(ref _disposed, 1) == 0)
                {
                    lock (_parent._gate)
                    {
                        if (!_parent._isDisposed)
                        {
                            _parent._subscriptions.TryRemove(this, out _);
                            if (_parent._subscriptions.IsEmpty)
                            {
                                _parent.Dispose();
                            }
                        }
                    }
                }
            }
        }
    }

    internal sealed class Disposable : IDisposable
    {
        public static readonly IDisposable Empty = new Disposable();
        private Disposable() { }
        public void Dispose() { }
    }
}";

    private const string WeakEventManagerSource = @"
using System;
using System.Collections.Concurrent;
using System.Reflection;
using System.Runtime.CompilerServices;

namespace ReactiveGenerator.Internal
{
    internal sealed class WeakEventManager<TDelegate> where TDelegate : class, Delegate
    {
        private readonly ConditionalWeakTable<object, EventRegistrationList> _registrations = 
            new ConditionalWeakTable<object, EventRegistrationList>();

        public void AddEventHandler(object source, string eventName, TDelegate handler)
        {
            if (source == null) throw new ArgumentNullException(nameof(source));
            if (eventName == null) throw new ArgumentNullException(nameof(eventName));
            if (handler == null) throw new ArgumentNullException(nameof(handler));

            var eventInfo = source.GetType().GetEvent(eventName);
            if (eventInfo == null)
            {
                throw new ArgumentException($""Event '{eventName}' not found on type '{source.GetType()}'."");
            }

            var list = _registrations.GetOrCreateValue(source);
            var registration = new WeakEventRegistration(eventInfo, handler);
            list.Add(registration);

            registration.Subscribe(source);
        }

        public void RemoveEventHandler(object source, string eventName, TDelegate handler)
        {
            if (source == null) throw new ArgumentNullException(nameof(source));
            if (eventName == null) throw new ArgumentNullException(nameof(eventName));
            if (handler == null) throw new ArgumentNullException(nameof(handler));

            if (_registrations.TryGetValue(source, out var list))
            {
                list.Remove(eventName, handler);
            }
        }

        private sealed class EventRegistrationList
        {
            private readonly ConcurrentDictionary<string, ConcurrentDictionary<TDelegate, WeakEventRegistration>> _registrations =
                new ConcurrentDictionary<string, ConcurrentDictionary<TDelegate, WeakEventRegistration>>();

            public void Add(WeakEventRegistration registration)
            {
                var eventHandlers = _registrations.GetOrAdd(
                    registration.EventInfo.Name,
                    _ => new ConcurrentDictionary<TDelegate, WeakEventRegistration>());

                eventHandlers[registration.Handler] = registration;
            }

            public void Remove(string eventName, TDelegate handler)
            {
                if (_registrations.TryGetValue(eventName, out var eventHandlers))
                {
                    if (eventHandlers.TryRemove(handler, out var registration))
                    {
                        registration.Unsubscribe();
                    }
                }
            }
        }

        private sealed class WeakEventRegistration
        {
            private readonly WeakReference<TDelegate> _weakDelegate;
            private readonly EventInfo _eventInfo;
            private readonly TDelegate _handler;

            public WeakEventRegistration(EventInfo eventInfo, TDelegate handler)
            {
                _eventInfo = eventInfo;
                _handler = handler;
                _weakDelegate = new WeakReference<TDelegate>(handler);
            }

            public EventInfo EventInfo => _eventInfo;
            public TDelegate Handler => _handler;

            public void Subscribe(object source)
            {
                if (_weakDelegate.TryGetTarget(out var handler))
                {
                    EventInfo.AddEventHandler(source, handler);
                }
            }

            public void Unsubscribe()
            {
                if (_weakDelegate.TryGetTarget(out var handler))
                {
                    _weakDelegate.SetTarget(null);
                }
            }
        }
    }
}";
}
