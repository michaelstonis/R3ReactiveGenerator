{
  Sources: [
    {
      FileName: BaseClass.WhenAnyValue.g.cs,
      Source:
// <auto-generated/>
#nullable enable

using System;
using System.ComponentModel;
using System.Threading;
using ReactiveGenerator.Internal;

namespace Global
{
    /// <summary>
    /// Provides extension methods for observing changes to properties of <see cref="BaseClass"/>.
    /// </summary>
    public static class BaseClassWhenAnyValueExtensions
    {
        /// <summary>
        /// Observes changes to the <see cref="BaseClass.BaseProp"/> property.
        /// </summary>
        /// <param name="source">The source object.</param>
        /// <returns>An observable sequence of <see cref="string"/> values.</returns>
        public static IObservable<string?> WhenAnyBaseProp(
            this global::BaseClass source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));

            return new PropertyObserver<global::BaseClass, string?>(
                source,
                "BaseProp",
                () => source.BaseProp);
        }
    }
}

    },
    {
      FileName: DerivedClass.WhenAnyValue.g.cs,
      Source:
// <auto-generated/>
#nullable enable

using System;
using System.ComponentModel;
using System.Threading;
using ReactiveGenerator.Internal;

namespace Global
{
    /// <summary>
    /// Provides extension methods for observing changes to properties of <see cref="DerivedClass"/>.
    /// </summary>
    public static class DerivedClassWhenAnyValueExtensions
    {
        /// <summary>
        /// Observes changes to the <see cref="DerivedClass.DerivedProp"/> property.
        /// </summary>
        /// <param name="source">The source object.</param>
        /// <returns>An observable sequence of <see cref="string"/> values.</returns>
        public static IObservable<string?> WhenAnyDerivedProp(
            this global::DerivedClass source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));

            return new PropertyObserver<global::DerivedClass, string?>(
                source,
                "DerivedProp",
                () => source.DerivedProp);
        }
    }
}

    },
    {
      FileName: PropertyObserver.g.cs,
      Source:
// <auto-generated/>
#nullable enable

using System;
using System.Collections.Concurrent;
using System.ComponentModel;
using System.Threading;

namespace ReactiveGenerator.Internal
{
    /// <summary>
    /// Observes property changes on a source object and notifies subscribers.
    /// </summary>
    /// <typeparam name="TSource">The type of the source object.</typeparam>
    /// <typeparam name="TProperty">The type of the property being observed.</typeparam>
    internal sealed class PropertyObserver<TSource, TProperty> : IObservable<TProperty>, IDisposable
        where TSource : INotifyPropertyChanged
    {
        private readonly object _gate = new object();
        private readonly TSource _source;
        private readonly string _propertyName;
        private readonly Func<TProperty> _getter;
        private readonly WeakEventManager<PropertyChangedEventHandler> _eventManager;
        private readonly PropertyChangedEventHandler _handler;
        private bool _isDisposed;
        private readonly ConcurrentDictionary<IDisposable, byte> _subscriptions;

        /// <summary>
        /// Initializes a new instance of the <see cref="PropertyObserver{TSource, TProperty}"/> class.
        /// </summary>
        /// <param name="source">The source object.</param>
        /// <param name="propertyName">The name of the property to observe.</param>
        /// <param name="getter">A function to get the property value.</param>
        public PropertyObserver(TSource source, string propertyName, Func<TProperty> getter)
        {
            if (source == null) throw new ArgumentNullException(nameof(source));
            if (propertyName == null) throw new ArgumentNullException(nameof(propertyName));
            if (getter == null) throw new ArgumentNullException(nameof(getter));

            _source = source;
            _propertyName = propertyName;
            _getter = getter;
            _eventManager = new WeakEventManager<PropertyChangedEventHandler>();
            _subscriptions = new ConcurrentDictionary<IDisposable, byte>();
            _handler = HandlePropertyChanged;
        }

        /// <summary>
        /// Subscribes an observer to receive notifications.
        /// </summary>
        /// <param name="observer">The observer to subscribe.</param>
        /// <returns>A disposable to unsubscribe the observer.</returns>
        public IDisposable Subscribe(IObserver<TProperty> observer)
        {
            if (observer == null) throw new ArgumentNullException(nameof(observer));

            lock (_gate)
            {
                if (_isDisposed)
                {
                    observer.OnCompleted();
                    return Disposable.Empty;
                }

                var subscription = new Subscription(this, observer);
                _subscriptions.TryAdd(subscription, 0);

                try
                {
                    observer.OnNext(_getter());
                    _eventManager.AddEventHandler(_source, "PropertyChanged", _handler);
                }
                catch (Exception ex)
                {
                    observer.OnError(ex);
                    subscription.Dispose();
                    return Disposable.Empty;
                }

                return subscription;
            }
        }

        private void HandlePropertyChanged(object? sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName != _propertyName && !string.IsNullOrEmpty(e.PropertyName)) 
                return;

            foreach (var subscription in _subscriptions.Keys)
            {
                if (subscription is Subscription activeSubscription)
                {
                    try
                    {
                        var observer = activeSubscription.Observer;
                        if (observer != null)
                        {
                            observer.OnNext(_getter());
                        }
                        else
                        {
                            activeSubscription.Dispose();
                        }
                    }
                    catch (Exception ex)
                    {
                        var observer = activeSubscription.Observer;
                        if (observer != null)
                        {
                            observer.OnError(ex);
                        }
                        activeSubscription.Dispose();
                    }
                }
            }
        }

        /// <summary>
        /// Disposes the observer and unsubscribes all observers.
        /// </summary>
        public void Dispose()
        {
            lock (_gate)
            {
                if (!_isDisposed)
                {
                    foreach (var subscription in _subscriptions.Keys)
                    {
                        subscription.Dispose();
                    }
                    _subscriptions.Clear();
                    _eventManager.RemoveEventHandler(_source, "PropertyChanged", _handler);
                    _isDisposed = true;
                }
            }
        }

        private sealed class Subscription : IDisposable
        {
            private readonly PropertyObserver<TSource, TProperty> _parent;
            private readonly WeakReference<IObserver<TProperty>> _weakObserver;
            private int _disposed;

            public Subscription(PropertyObserver<TSource, TProperty> parent, IObserver<TProperty> observer)
            {
                _parent = parent;
                _weakObserver = new WeakReference<IObserver<TProperty>>(observer);
            }

            /// <summary>
            /// Gets the observer if it is still alive.
            /// </summary>
            public IObserver<TProperty>? Observer
            {
                get => _weakObserver.TryGetTarget(out var observer) ? observer : null;
            }

            /// <summary>
            /// Disposes the subscription and removes it from the parent observer.
            /// </summary>
            public void Dispose()
            {
                if (Interlocked.Exchange(ref _disposed, 1) == 0)
                {
                    lock (_parent._gate)
                    {
                        if (!_parent._isDisposed)
                        {
                            _parent._subscriptions.TryRemove(this, out _);
                            if (_parent._subscriptions.IsEmpty)
                            {
                                _parent.Dispose();
                            }
                        }
                    }
                }
            }
        }
    }

    /// <summary>
    /// Represents a disposable resource that does nothing when disposed.
    /// </summary>
    internal sealed class Disposable : IDisposable
    {
        /// <summary>
        /// Gets a disposable that does nothing when disposed.
        /// </summary>
        public static readonly IDisposable Empty = new Disposable();

        private Disposable() { }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose() { }
    }
}
    },
    {
      FileName: WeakEventManager.g.cs,
      Source:
// <auto-generated/>
#nullable enable

using System;
using System.Collections.Concurrent;
using System.Reflection;
using System.Runtime.CompilerServices;

namespace ReactiveGenerator.Internal
{
    /// <summary>
    /// Manages weak event subscriptions to avoid memory leaks.
    /// </summary>
    /// <typeparam name="TDelegate">The type of the event handler delegate.</typeparam>
    internal sealed class WeakEventManager<TDelegate> where TDelegate : class, Delegate
    {
        private readonly ConditionalWeakTable<object, EventRegistrationList> _registrations =
            new ConditionalWeakTable<object, EventRegistrationList>();

        /// <summary>
        /// Adds a weak event handler to the specified event on the source object.
        /// </summary>
        /// <param name="source">The source object.</param>
        /// <param name="eventName">The name of the event.</param>
        /// <param name="handler">The event handler.</param>
        public void AddEventHandler(object source, string eventName, TDelegate handler)
        {
            if (source == null) throw new ArgumentNullException(nameof(source));
            if (eventName == null) throw new ArgumentNullException(nameof(eventName));
            if (handler == null) throw new ArgumentNullException(nameof(handler));

            var eventInfo = source.GetType().GetEvent(eventName);
            if (eventInfo == null)
            {
                throw new ArgumentException($"Event '{eventName}' not found on type '{source.GetType()}'.");
            }

            var list = _registrations.GetOrCreateValue(source);
            var registration = new WeakEventRegistration(source, eventInfo, handler);
            list.Add(registration);
        }

        /// <summary>
        /// Removes a weak event handler from the specified event on the source object.
        /// </summary>
        /// <param name="source">The source object.</param>
        /// <param name="eventName">The name of the event.</param>
        /// <param name="handler">The event handler.</param>
        public void RemoveEventHandler(object source, string eventName, TDelegate handler)
        {
            if (source == null) throw new ArgumentNullException(nameof(source));
            if (eventName == null) throw new ArgumentNullException(nameof(eventName));
            if (handler == null) throw new ArgumentNullException(nameof(handler));

            if (_registrations.TryGetValue(source, out var list))
            {
                list.Remove(eventName, handler);
            }
        }

        private sealed class EventRegistrationList
        {
            private readonly ConcurrentDictionary<string, ConcurrentDictionary<TDelegate, WeakEventRegistration>> _registrations =
                new ConcurrentDictionary<string, ConcurrentDictionary<TDelegate, WeakEventRegistration>>();

            public void Add(WeakEventRegistration registration)
            {
                var eventHandlers = _registrations.GetOrAdd(
                    registration.EventInfo.Name,
                    _ => new ConcurrentDictionary<TDelegate, WeakEventRegistration>());

                eventHandlers[registration.Handler] = registration;
            }

            public void Remove(string eventName, TDelegate handler)
            {
                if (_registrations.TryGetValue(eventName, out var eventHandlers))
                {
                    if (eventHandlers.TryRemove(handler, out var registration))
                    {
                        registration.Unsubscribe();
                    }
                }
            }
        }

        private sealed class WeakEventRegistration
        {
            private readonly WeakReference _sourceReference;
            private readonly WeakReference<TDelegate> _handlerReference;
            private readonly EventInfo _eventInfo;

            public WeakEventRegistration(object source, EventInfo eventInfo, TDelegate handler)
            {
                _sourceReference = new WeakReference(source);
                _eventInfo = eventInfo;
                _handlerReference = new WeakReference<TDelegate>(handler);

                Subscribe();
            }

            /// <summary>
            /// Gets the event information for the event being managed.
            /// </summary>
            public EventInfo EventInfo => _eventInfo;

            /// <summary>
            /// Gets the event handler delegate.
            /// </summary>
            public TDelegate Handler
            {
                get
                {
                    _handlerReference.TryGetTarget(out var handler);
                    return handler!;
                }
            }

            private void Subscribe()
            {
                if (_sourceReference.Target is object source &&
                    _handlerReference.TryGetTarget(out var handler))
                {
                    _eventInfo.AddEventHandler(source, handler);
                }
            }

            /// <summary>
            /// Unsubscribes the handler from the event.
            /// </summary>
            public void Unsubscribe()
            {
                if (_sourceReference.Target is object source &&
                    _handlerReference.TryGetTarget(out var handler))
                {
                    _eventInfo.RemoveEventHandler(source, handler);
                }
            }
        }
    }
}
    }
  ],
  Diagnostics: null
}